import { AlbJwksCache } from "./alb-cache.js";
import { assertStringArrayContainsString } from "./assert.js";
import { AlbJwtInvalidClientIdError, AlbJwtInvalidSignerError, JwtInvalidClaimError, ParameterValidationError, } from "./error.js";
import { JwtVerifierBase } from "./jwt-verifier.js";
const ALB_ARN_REGEX = /^arn:(?:aws|aws-cn):elasticloadbalancing:([a-z]{2}-(?:gov-)?[a-z]+-\d{1}):.+$/;
/**
 * Class representing a verifier for JWTs signed by AWS ALB
 */
export class AlbJwtVerifier extends JwtVerifierBase {
    constructor(props, jwksCache) {
        const transformPropertiesToIssuerConfig = (props) => {
            const albArns = validateAndParseAlbArns(props.albArn);
            return {
                jwksUri: props.jwksUri ?? getDefaultJwksUri(albArns),
                ...props,
                audience: null,
            };
        };
        const issuerConfig = Array.isArray(props)
            ? props.map(transformPropertiesToIssuerConfig)
            : transformPropertiesToIssuerConfig(props);
        super(issuerConfig, jwksCache);
    }
    static create(verifyProperties, additionalProperties) {
        return new this(verifyProperties, additionalProperties?.jwksCache ?? new AlbJwksCache());
    }
    /**
     * Verify (synchronously) a JWT that is signed by AWS Application Load Balancer.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown
     */
    verifySync(...[jwt, properties]) {
        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);
        try {
            this.verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties);
            validateAlbJwtFields(decomposedJwt.header, verifyProperties);
        }
        catch (err) {
            if (verifyProperties.includeRawJwtInErrors &&
                err instanceof JwtInvalidClaimError) {
                throw err.withRawJwt(decomposedJwt);
            }
            throw err;
        }
        return decomposedJwt.payload;
    }
    /**
     * Verify (asynchronously) a JWT that is signed by AWS Application Load Balancer.
     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,
     * in case it is not yet available in the cache.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
     */
    async verify(...[jwt, properties]) {
        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);
        try {
            await this.verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties);
            validateAlbJwtFields(decomposedJwt.header, verifyProperties);
        }
        catch (err) {
            if (verifyProperties.includeRawJwtInErrors &&
                err instanceof JwtInvalidClaimError) {
                throw err.withRawJwt(decomposedJwt);
            }
            throw err;
        }
        return decomposedJwt.payload;
    }
}
export function validateAlbJwtFields(header, options) {
    // Check ALB ARN (signer)
    assertStringArrayContainsString("ALB ARN", header.signer, options.albArn, AlbJwtInvalidSignerError);
    // Check clientId
    if (options.clientId !== null) {
        if (options.clientId === undefined) {
            throw new ParameterValidationError("clientId must be provided or set to null explicitly");
        }
        assertStringArrayContainsString("Client ID", header.client, options.clientId, AlbJwtInvalidClientIdError);
    }
}
export function validateAndParseAlbArns(albArn) {
    if (Array.isArray(albArn)) {
        return albArn.map(parseAlbArn);
    }
    else {
        return [parseAlbArn(albArn)];
    }
}
function parseAlbArn(albArn) {
    const match = ALB_ARN_REGEX.exec(albArn);
    if (!match) {
        throw new ParameterValidationError(`Invalid load balancer ARN: ${albArn}`);
    }
    return {
        region: match[1],
    };
}
function getDefaultJwksUri(albArns) {
    const regions = albArns.map((arn) => arn.region);
    const uniqueRegions = Array.from(new Set(regions));
    if (uniqueRegions.length > 1) {
        throw new ParameterValidationError("Using ALBs from different regions is not supported for the same issuer");
    }
    return `https://public-keys.auth.elb.${uniqueRegions[0]}.amazonaws.com`;
}
