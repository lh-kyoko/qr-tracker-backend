import { AlbJwksNotExposedError, JwksNotAvailableInCacheError, JwksValidationError, JwkValidationError, JwtWithoutValidKidError, } from "./error.js";
import { SimpleFetcher } from "./https.js";
import { SimpleLruCache } from "./cache.js";
import { nodeWebCompat } from "#node-web-compat";
const UUID_REGEXP = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
export class AlbJwksCache {
    constructor(props) {
        this.jwkCache = new SimpleLruCache(2);
        this.fetchingJwks = new Map();
        this.fetcher = props?.fetcher ?? new SimpleFetcher();
    }
    expandWithKid(jwksUri, kid) {
        return `${jwksUri}/${encodeURIComponent(kid)}`;
    }
    getKid(decomposedJwt) {
        const kid = decomposedJwt.header.kid;
        if (typeof kid !== "string" || !this.isValidAlbKid(kid)) {
            throw new JwtWithoutValidKidError("JWT header does not have valid kid claim");
        }
        return kid;
    }
    isValidAlbKid(kid) {
        return UUID_REGEXP.test(kid);
    }
    async getJwk(jwksUri, decomposedJwt) {
        const kid = this.getKid(decomposedJwt);
        const jwksUriWithKid = this.expandWithKid(jwksUri, kid);
        const jwk = this.jwkCache.get(jwksUriWithKid);
        if (jwk) {
            //cache hit
            return jwk;
        }
        else {
            //cache miss
            const fetchPromise = this.fetchingJwks.get(jwksUriWithKid);
            if (fetchPromise) {
                return fetchPromise;
            }
            else {
                const newFetchPromise = this.fetcher
                    .fetch(jwksUriWithKid)
                    .then((pem) => this.pemToJwk(kid, pem))
                    .then((jwk) => {
                    this.jwkCache.set(jwksUriWithKid, jwk);
                    return jwk;
                })
                    .finally(() => {
                    this.fetchingJwks.delete(jwksUriWithKid);
                });
                this.fetchingJwks.set(jwksUriWithKid, newFetchPromise);
                return newFetchPromise;
            }
        }
    }
    async pemToJwk(kid, pem) {
        const jwk = await nodeWebCompat.transformPemToJwk(pem);
        return {
            ...jwk,
            use: "sig",
            alg: "ES256",
            kid: kid,
        };
    }
    getCachedJwk(jwksUri, decomposedJwt) {
        const kid = this.getKid(decomposedJwt);
        const jwksUriWithKid = this.expandWithKid(jwksUri, kid);
        const jwk = this.jwkCache.get(jwksUriWithKid);
        if (jwk) {
            return jwk;
        }
        else {
            throw new JwksNotAvailableInCacheError(`JWKS for uri ${jwksUri} not yet available in cache`);
        }
    }
    addJwks(jwksUri, jwks) {
        if (jwks.keys.length === 1) {
            const jwk = jwks.keys[0];
            if (jwk.kid) {
                const jwksUriWithKid = this.expandWithKid(jwksUri, jwk.kid);
                this.jwkCache.set(jwksUriWithKid, jwk);
            }
            else {
                throw new JwkValidationError("JWK does not have a kid");
            }
        }
        else {
            throw new JwksValidationError("Only one JWK is expected in the JWKS");
        }
    }
    async getJwks() {
        throw new AlbJwksNotExposedError("AWS ALB does not expose JWKS");
    }
}
