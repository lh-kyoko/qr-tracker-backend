"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlbJwksCache = void 0;
const error_js_1 = require("./error.js");
const https_js_1 = require("./https.js");
const cache_js_1 = require("./cache.js");
const _node_web_compat_1 = require("#node-web-compat");
const UUID_REGEXP = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
class AlbJwksCache {
    constructor(props) {
        this.jwkCache = new cache_js_1.SimpleLruCache(2);
        this.fetchingJwks = new Map();
        this.fetcher = props?.fetcher ?? new https_js_1.SimpleFetcher();
    }
    expandWithKid(jwksUri, kid) {
        return `${jwksUri}/${encodeURIComponent(kid)}`;
    }
    getKid(decomposedJwt) {
        const kid = decomposedJwt.header.kid;
        if (typeof kid !== "string" || !this.isValidAlbKid(kid)) {
            throw new error_js_1.JwtWithoutValidKidError("JWT header does not have valid kid claim");
        }
        return kid;
    }
    isValidAlbKid(kid) {
        return UUID_REGEXP.test(kid);
    }
    async getJwk(jwksUri, decomposedJwt) {
        const kid = this.getKid(decomposedJwt);
        const jwksUriWithKid = this.expandWithKid(jwksUri, kid);
        const jwk = this.jwkCache.get(jwksUriWithKid);
        if (jwk) {
            //cache hit
            return jwk;
        }
        else {
            //cache miss
            const fetchPromise = this.fetchingJwks.get(jwksUriWithKid);
            if (fetchPromise) {
                return fetchPromise;
            }
            else {
                const newFetchPromise = this.fetcher
                    .fetch(jwksUriWithKid)
                    .then((pem) => this.pemToJwk(kid, pem))
                    .then((jwk) => {
                    this.jwkCache.set(jwksUriWithKid, jwk);
                    return jwk;
                })
                    .finally(() => {
                    this.fetchingJwks.delete(jwksUriWithKid);
                });
                this.fetchingJwks.set(jwksUriWithKid, newFetchPromise);
                return newFetchPromise;
            }
        }
    }
    async pemToJwk(kid, pem) {
        const jwk = await _node_web_compat_1.nodeWebCompat.transformPemToJwk(pem);
        return {
            ...jwk,
            use: "sig",
            alg: "ES256",
            kid: kid,
        };
    }
    getCachedJwk(jwksUri, decomposedJwt) {
        const kid = this.getKid(decomposedJwt);
        const jwksUriWithKid = this.expandWithKid(jwksUri, kid);
        const jwk = this.jwkCache.get(jwksUriWithKid);
        if (jwk) {
            return jwk;
        }
        else {
            throw new error_js_1.JwksNotAvailableInCacheError(`JWKS for uri ${jwksUri} not yet available in cache`);
        }
    }
    addJwks(jwksUri, jwks) {
        if (jwks.keys.length === 1) {
            const jwk = jwks.keys[0];
            if (jwk.kid) {
                const jwksUriWithKid = this.expandWithKid(jwksUri, jwk.kid);
                this.jwkCache.set(jwksUriWithKid, jwk);
            }
            else {
                throw new error_js_1.JwkValidationError("JWK does not have a kid");
            }
        }
        else {
            throw new error_js_1.JwksValidationError("Only one JWK is expected in the JWKS");
        }
    }
    async getJwks() {
        throw new error_js_1.AlbJwksNotExposedError("AWS ALB does not expose JWKS");
    }
}
exports.AlbJwksCache = AlbJwksCache;
